import numpy as np
import math
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import numpy.matlib
import cv2
from pynq.overlays.base import BaseOverlay
from pynq.lib.video import *
base = BaseOverlay("base.bit")



def get_file(file_name,zoom_k):
    point_cloud=[]
    with open(file_name,'r') as file_read:
        print("readin file ", (file_name))
        count=0
        while True:
            line=file_read.readline()
            if not line:
                break
            x_tmp,y_tmp,z_tmp,f_1,f_2,f_3=[float(i) for i in line.split()]
            point = np.zeros((3,1), dtype = np.float) #important for address reflush
            point[0]=x_tmp*zoom_k
            point[1]=y_tmp*zoom_k
            point[2]=z_tmp*zoom_k
            point_cloud.append(point)
            count=count+1
    point_cloud=np.array(point_cloud)
    print(point_cloud)
    print("read finished with ",(len(point_cloud))," points")
    file_read.close()
    return point_cloud

def gen_rotatex(rad_x):
    mat_rotx=np.matlib.identity(4,np.float)
    mat_rotx[1,1]=math.cos(rad_x)
    mat_rotx[1,2]=math.sin(rad_x)
    mat_rotx[2,1]=-1*math.sin(rad_x)
    mat_rotx[2,2]=math.cos(rad_x)
    print(mat_rotx)
    return mat_rotx

def gen_rotatey(rad_y):
    mat_roty=np.matlib.identity(4,np.float)
    mat_roty[0,0]=math.cos(rad_y)
    mat_roty[0,2]=math.sin(rad_y)
    mat_roty[2,0]=-1*math.sin(rad_y)
    mat_roty[2,2]=math.cos(rad_y)
    print(mat_roty)
    return mat_roty


def gen_rotatez(rad_z):
    mat_rotz=np.matlib.identity(4,np.float)
    mat_rotz[0,0]=math.cos(rad_z)
    mat_rotz[0,1]=math.sin(rad_z)
    mat_rotz[1,0]=-1*math.sin(rad_z)
    mat_rotz[1,1]=math.cos(rad_z)
    print(mat_rotz)
    return mat_rotz

def gen_rotmat(rad_x,rad_y,rad_z):
    mat_rotx=gen_rotatex(rad_x)
    mat_roty=gen_rotatey(rad_y)
    mat_rotz=gen_rotatez(rad_z)
    mat_rot=np.matlib.identity(4,np.float)
    mat_rot=mat_rotx*mat_roty*mat_rotz
    return mat_rot

def gen_transmat(x,y,z):
    mat_trans=np.matlib.identity(4,np.float)
    mat_trans[3,0]=x
    mat_trans[3,1]=y
    mat_trans[3,2]=z
    print(mat_trans)
    return mat_trans

def gen_projection( fov_deg, aspect_retio, near_f, far_f):
    fov_rad = 1.0 / math.tan(fov_deg * 0.5 / 180.0 * math.pi)
    result=np.zeros((4,4))
    result[0,0] = aspect_retio * fov_rad
    result[1,1] = fov_rad
    result[2,2] = far_f / (far_f - near_f)
    result[3,2] = (-far_f * near_f) / (far_f - near_f)
    result[2,3] = 1.0
    result[3,3] = 0.0
    print(result)
    return result

def draw_point(p_x,p_y):
    plt.scatter(p_x,p_y)
    plt.xlabel('x_axis')
    plt.ylabel('y_axis')
    plt.title('test_pcl_draw')
    plt.show()

def draw_point_3d(p_x,p_y,p_z):
    fig=plt.figure();
    ax = fig.add_subplot(111, projection='3d')
    ax.scatter(p_x,p_y,p_z,c='k',marker='.',s=0.1)
    plt.show()

def draw_point_cv(image_show):
    pass

def point_simplify(point_input,div_rate):
    ori_size=len(point_input)
    point_output=[]
    count=0
    for point_single in point_input:
        if count==0:
            point_output.append(point_single)
        count=count+1
        if count==div_rate:
            count=0
    return point_output

 
def main():
    point_cloud=get_file("point-cloud-sample/horse.xyz",8.0)
    print("point cloud file read done")
    point_cloud=point_simplify(point_cloud,50)

    near_f=0.1
    far_f=1000.0
    fov_angle=90.0

    screen_w=640
    screen_h=480

    aspect_ratio=screen_h/screen_w

    display_angle=0
    display_offset={0,0,3.0}

    mat_projection=gen_projection(fov_angle, aspect_ratio, near_f, far_f)
    
    Mode = VideoMode(640,480,24)
    hdmi_out = base.video.hdmi_out
    hdmi_out.configure(Mode,PIXEL_BGR)
    hdmi_out.start()
    print("HDMI Initialized\n")

    #cv2.namedWindow("test")
    while True:
        display_angle+=0.05
        mat_rot=gen_rotmat(display_angle,display_angle,display_angle)
        mat_trans=gen_transmat(0,0,3.0)
        
        #x_2d=[]
        #y_2d=[]

        #x_3d=[]
        #y_3d=[]
        #z_3d=[]
        outframe = hdmi_out.newframe()
        outframe[0:480,0:640,:]=255
        
        for point_single in point_cloud:
            point_single4=np.zeros((4,1), dtype = np.float)
            point_single4[3]=1.0

            point_single4[0]=point_single[0]
            point_single4[1]=point_single[1]
            point_single4[2]=point_single[2]

            point_rot=mat_rot*point_single4
            point_trans=mat_trans*point_rot
            point_proj=mat_projection*point_trans

            #point_rot=np.multiply(mat_rot,point_single4)
            #point_trans=np.multiply(mat_trans,point_rot)
            #point_proj=np.multiply(mat_projection,point_trans)#faster numpy calculation

            #point_proj=mat_projection*mat_trans*mat_rot*point_single4

            #x_3d.append(point_trans[0])
            #y_3d.append(point_trans[1])
            #z_3d.append(point_trans[2])

            point_proj[0]+=1.0
            point_proj[1]+=1.0
            point_proj[0]*=0.5*screen_w
            point_proj[1]*=0.5*screen_h

            #output_image[int(point_proj[1]),int(point_proj[0]),2]=255
            outframe[int(point_proj[1]),int(point_proj[0]),0]=0
            outframe[int(point_proj[1]),int(point_proj[0]),1]=0

            #x_2d.append(point_proj[0])
            #y_2d.append(point_proj[1])

        #draw_point(x_2d,y_2d)
        #cv2.imshow("test",output_image)
        #cv2.waitKey(0)
        print("cycle test")
        hdmi_out.writeframe(outframe)
        print("frame output finished")
        
    pass
    hdmi_out.stop()
    del hdmi_out
    
    #cv2.destoryAllWindows()
        


 
if __name__ == '__main__':
    main()
    print ('now __name__ is %s' %__name__)

