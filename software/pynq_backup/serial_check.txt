import numpy as np
import math
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import numpy.matlib
import cv2
from pynq.overlays.base import BaseOverlay
from pynq.lib.video import *
from pynq.lib import MicroblazeLibrary
import cv2
base = BaseOverlay("base.bit")

lib = MicroblazeLibrary(base.RPI, ['uart'])
uart_device = lib.uart_open(14,15)# normal uart speed 9600

#####################################################################################

def get_file(file_name,zoom_k):
    point_cloud=[]
    with open(file_name,'r') as file_read:
        print("readin file ", (file_name))
        count=0
        while True:
            line=file_read.readline()
            if not line:
                break
            x_tmp,y_tmp,z_tmp,f_1,f_2,f_3=[float(i) for i in line.split()]
            point = np.zeros((3,1), dtype = np.float) #important for address reflush
            point[0]=x_tmp*zoom_k
            point[1]=y_tmp*zoom_k
            point[2]=z_tmp*zoom_k
            point_cloud.append(point)
            count=count+1
    point_cloud=np.array(point_cloud)
    print(point_cloud)
    print("read finished with ",(len(point_cloud))," points")
    file_read.close()
    return point_cloud

def gen_rotatex(rad_x):
    mat_rotx=np.matlib.identity(4,np.float)
    mat_rotx[1,1]=math.cos(rad_x)
    mat_rotx[1,2]=math.sin(rad_x)
    mat_rotx[2,1]=-1*math.sin(rad_x)
    mat_rotx[2,2]=math.cos(rad_x)
    #print(mat_rotx)
    return mat_rotx

def gen_rotatey(rad_y):
    mat_roty=np.matlib.identity(4,np.float)
    mat_roty[0,0]=math.cos(rad_y)
    mat_roty[0,2]=math.sin(rad_y)
    mat_roty[2,0]=-1*math.sin(rad_y)
    mat_roty[2,2]=math.cos(rad_y)
    #print(mat_roty)
    return mat_roty


def gen_rotatez(rad_z):
    mat_rotz=np.matlib.identity(4,np.float)
    mat_rotz[0,0]=math.cos(rad_z)
    mat_rotz[0,1]=math.sin(rad_z)
    mat_rotz[1,0]=-1*math.sin(rad_z)
    mat_rotz[1,1]=math.cos(rad_z)
    #print(mat_rotz)
    return mat_rotz

def gen_rotmat(rad_x,rad_y,rad_z):
    mat_rotx=gen_rotatex(rad_x)
    mat_roty=gen_rotatey(rad_y)
    mat_rotz=gen_rotatez(rad_z)
    mat_rot=np.matlib.identity(4,np.float)
    mat_rot=mat_rotx*mat_roty*mat_rotz
    return mat_rot

def gen_transmat(x,y,z):
    mat_trans=np.matlib.identity(4,np.float)
    mat_trans[3,0]=x
    mat_trans[3,1]=y
    mat_trans[3,2]=z
    #print(mat_trans)
    return mat_trans

def gen_projection( fov_deg, aspect_retio, near_f, far_f):
    fov_rad = 1.0 / math.tan(fov_deg * 0.5 / 180.0 * math.pi)
    result=np.zeros((4,4))
    result[0,0] = aspect_retio * fov_rad
    result[1,1] = fov_rad
    result[2,2] = far_f / (far_f - near_f)
    result[3,2] = (-far_f * near_f) / (far_f - near_f)
    result[2,3] = 1.0
    result[3,3] = 0.0
    print(result)
    return result

def draw_point(p_x,p_y):
    plt.scatter(p_x,p_y)
    plt.xlabel('x_axis')
    plt.ylabel('y_axis')
    plt.title('test_pcl_draw')
    plt.show()

def draw_point_3d(p_x,p_y,p_z):
    fig=plt.figure();
    ax = fig.add_subplot(111, projection='3d')
    ax.scatter(p_x,p_y,p_z,c='k',marker='.',s=0.1)
    plt.show()

def draw_point_cv(image_show):
    pass

def point_simplify(point_input,div_rate):
    ori_size=len(point_input)
    point_output=[]
    count=0
    for point_single in point_input:
        if count==0:
            point_output.append(point_single)
        count=count+1
        if count==div_rate:
            count=0
    return point_output

########################################################################

def in_range(ascii_in):
    if(ascii_in>=48 and ascii_in<=57):
        return 1
    else:
        return 0
    pass


def read_to_float(list_read):
    result=0
    ten_num=2
    for item in list_read:
        result=result+(item-48)*10**(ten_num)
        ten_num=ten_num-1
        pass
    return result
    pass


def get_device_angle(angle_read):
    temp=[0]
    temp1=[]
    read_done=[0,0,0]
    checked=0
    #angle_read=[0,0,0]
    
    while(read_done[0]==0 or read_done[1]==0 or read_done[2]==0 or checked==0):
        
        lib.uart_read(uart_device,temp, 1)
        
        if(temp[0]==97):#selation a
            #print("a")
            count=0
            while(count<3):
                single=[0]
                lib.uart_read(uart_device,single, 1)
                if(temp!=0):
                    temp1.append(single[0])
                    count+=1
                    pass
                pass
            print(temp1)
            angle_1=read_to_float(temp1)
            if(angle_1<500):
                angle_read[0]=angle_1
            else:
                angle_read[0]=angle_1-500
            temp1=[]
            read_done[0]=1
            pass
    
        if(temp[0]==98):#selation b
            #print("b")
            count=0
            while(count<3):
                single=[0]
                lib.uart_read(uart_device,single, 1)
                if(temp!=0):
                    temp1.append(single[0])
                    count+=1
                    pass
                pass
            print(temp1)
            angle_read[1]=read_to_float(temp1)
            temp1=[]
            read_done[1]=1
            pass
    
        if(temp[0]==99):#selation c
            #print("c")
            count=0
            while(count<3):
                single=[0]
                lib.uart_read(uart_device,single, 1)
                if(temp!=0):
                    temp1.append(single[0])
                    count+=1
                    pass
                pass
            print(temp1)
            angle_read[2]=read_to_float(temp1)
            temp1=[]
            read_done[2]=1
            pass     
        
        if(temp[0]==100):#selation d
            #print("c")
            count=0
            check_sum=0
            while(count<3):
                single=[0]
                lib.uart_read(uart_device,single, 1)
                if(temp!=0):
                    temp1.append(single[0])
                    count+=1
                    pass
                pass
            print(temp1)
            check_sum=read_to_float(temp1)
            #print(abs(check_sum-((int((angle_read[0]+angle_read[1]+angle_read[2])/10))+100)))
            if(abs(check_sum-((int((angle_read[0]+angle_read[1]+angle_read[2])/10))+100))<2):#check sum
                checked=1
            temp1=[]
            pass  

    return angle_read

angle_read=[0,0,0]

########################################################################

def forward_kinematics(device_angle,link_len):
    device_end_pos=[0,0,0]
    
    l1=link_len[0]
    l2=link_len[1]
    l3=link_len[2]
    
    a1=device_angle[0]
    a2=device_angle[1]
    a3=device_angle[2]
    
    x_temp=l2*math.cos(a1)*math.cos(a2) + l3*math.cos(a1)*math.cos(a2)*math.cos(a3) - l3*math.cos(a1)*math.sin(a2)*math.sin(a3)
    y_temp=l2*math.cos(a2)*math.sin(a1) + l3*math.cos(a2)*math.cos(a3)*math.sin(a1) - l3*math.sin(a1)*math.sin(a2)*math.sin(a3)
    z_temp=l1 + l2*math.sin(a2) + l3*math.cos(a2)*math.sin(a3) + l3*math.cos(a3)*math.sin(a2)
    
    device_end_pos[0]=x_temp
    device_end_pos[1]=y_temp
    device_end_pos[2]=z_temp
    
    return device_end_pos
    pass

def inverse_dynamatics(device_angle,link_len,end_force):
    device_torque=[0,0,0]
    
    l1=link_len[0]
    l2=link_len[1]
    l3=link_len[2]
    
    a1=device_angle[0]
    a2=device_angle[1]
    a3=device_angle[2]
    
    fx=end_force[0]
    fy=end_force[1]
    fz=end_force[2]
    
    t1_temp=(fy*math.cos(a1))/(l2*math.cos(a1)**2*math.cos(a2) + l2*math.cos(a2)*math.sin(a1)**2 + l3*math.cos(a1)**2*math.cos(a2)*math.cos(a3) + l3*math.cos(a2)*math.cos(a3)*math.sin(a1)**2 - l3*math.cos(a1)**2*math.sin(a2)*math.sin(a3) - l3*math.sin(a1)**2*math.sin(a2)*math.sin(a3)) - (fx*math.sin(a1))/(l2*math.cos(a1)**2*math.cos(a2) + l2*math.cos(a2)*math.sin(a1)**2 + l3*math.cos(a1)**2*math.cos(a2)*math.cos(a3) + l3*math.cos(a2)*math.cos(a3)*math.sin(a1)**2 - l3*math.cos(a1)**2*math.sin(a2)*math.sin(a3) - l3*math.sin(a1)**2*math.sin(a2)*math.sin(a3))
    t2_temp=(fz*(math.cos(a2)*math.sin(a3) + math.cos(a3)*math.sin(a2)))/(l2*math.cos(a2)**2*math.sin(a3) + l2*math.sin(a2)**2*math.sin(a3)) - (fx*math.cos(a1)*(math.sin(a2)*math.sin(a3) - math.cos(a2)*math.cos(a3)))/(l2*math.sin(a1)**2*math.sin(a2)**2*math.sin(a3) + l2*math.cos(a1)**2*math.cos(a2)**2*math.sin(a3) + l2*math.cos(a1)**2*math.sin(a2)**2*math.sin(a3) + l2*math.cos(a2)**2*math.sin(a1)**2*math.sin(a3)) - (fy*math.sin(a1)*(math.sin(a2)*math.sin(a3) - math.cos(a2)*math.cos(a3)))/(l2*math.sin(a1)**2*math.sin(a2)**2*math.sin(a3) + l2*math.cos(a1)**2*math.cos(a2)**2*math.sin(a3) + l2*math.cos(a1)**2*math.sin(a2)**2*math.sin(a3) + l2*math.cos(a2)**2*math.sin(a1)**2*math.sin(a3))
    t3_temp=-1* (fx*(l2*math.cos(a1)*math.cos(a2) + l3*math.cos(a1)*math.cos(a2)*math.cos(a3) - l3*math.cos(a1)*math.sin(a2)*math.sin(a3)))/(l2*l3*math.cos(a1)**2*math.cos(a2)**2*math.sin(a3) + l2*l3*math.cos(a1)**2*math.sin(a2)**2*math.sin(a3) + l2*l3*math.cos(a2)**2*math.sin(a1)**2*math.sin(a3) + l2*l3*math.sin(a1)**2*math.sin(a2)**2*math.sin(a3)) - (fy*(l2*math.cos(a2)*math.sin(a1) + l3*math.cos(a2)*math.cos(a3)*math.sin(a1) - l3*math.sin(a1)*math.sin(a2)*math.sin(a3)))/(l2*l3*math.cos(a1)**2*math.cos(a2)**2*math.sin(a3) + l2*l3*math.cos(a1)**2*math.sin(a2)**2*math.sin(a3) + l2*l3*math.cos(a2)**2*math.sin(a1)**2*math.sin(a3) + l2*l3*math.sin(a1)**2*math.sin(a2)**2*math.sin(a3)) - (fz*(l2*math.sin(a2) + l3*math.cos(a2)*math.sin(a3) + l3*math.cos(a3)*math.sin(a2)))/(l2*l3*math.cos(a2)**2*math.sin(a3) + l2*l3*math.sin(a2)**2*math.sin(a3))
    
    device_torque[0]=t1_temp
    device_torque[1]=t2_temp
    device_torque[2]=t3_temp
    
    return device_torque
    pass


########################################################################

def virtual_env_setup(x_wall_pos):
    env_cloud=[]
    step=16
    axis_po=0
    for i in range(1,5) :
        point_temp_x = np.zeros((3,1), dtype = np.float) #important for address reflush
        point_temp_y = np.zeros((3,1), dtype = np.float)
        point_temp_z = np.zeros((3,1), dtype = np.float)
        point_temp_x[0]=axis_po
        point_temp_y[1]=axis_po
        point_temp_z[2]=axis_po
        env_cloud.append(point_temp_x)
        env_cloud.append(point_temp_y)
        env_cloud.append(point_temp_z)
        axis_po=axis_po+step*2
    
    for s in range(-3,3):
        for t in range(-3,3):
            point_temp_wall = np.zeros((3,1), dtype = np.float)
            point_temp_wall[0]=x_wall_pos
            point_temp_wall[1]=t*step*3
            point_temp_wall[2]=s*step*3
            env_cloud.append(point_temp_wall)
            pass
        pass
    
    env_cloud=np.array(env_cloud)
    return env_cloud
    pass

########################################################################


 
def main():
    #point_cloud=get_file("axis.xyz",3)
    print("point cloud file read done")
    #point_cloud=point_simplify(point_cloud,10)
    point_cloud=virtual_env_setup(25)
    
    device_angle=[0.2,0,0]
    link_len=[22.5,230,210]
    angle_read=[0,0,0]

    #display setup
    near_f=0.1
    far_f=1000.0
    fov_angle=90.0

    screen_w=640
    screen_h=480

    aspect_ratio=screen_h/screen_w

    display_angle=0
    display_offset={0,0,3.0}

    mat_projection=gen_projection(fov_angle, aspect_ratio, near_f, far_f)
    
    #hdmi setup
    Mode = VideoMode(640,480,24)
    hdmi_out = base.video.hdmi_out
    hdmi_out.configure(Mode,PIXEL_BGR)
    hdmi_out.start()
    print("HDMI Initialized\n")

    
    for s in range (0,1000):
        display_angle+=0.03
        mat_rot=gen_rotmat(-1*math.pi/2,0,display_angle)
        mat_trans=gen_transmat(0,0,3.0)
        
        outframe = hdmi_out.newframe()
        outframe[0:480,0:640,:]=0
        
        for point_single in point_cloud:
            point_single4=np.zeros((4,1), dtype = np.float)
            point_single4[3]=1.0

            point_single4[0]=point_single[0]
            point_single4[1]=point_single[1]
            point_single4[2]=point_single[2]

            point_rot=mat_rot*point_single4
            point_trans=mat_trans*point_rot
            point_proj=mat_projection*point_trans

            point_proj[0]+=0.5*screen_w
            point_proj[1]+=0.5*screen_h
            #point_proj[0]*=0.5*screen_w
            #point_proj[1]*=0.5*screen_h
            
            y_int=int(point_proj[1])
            x_int=int(point_proj[0])
            if(x_int>640-1-6):
                x_int=640-1-6
            if(x_int<6):
                x_int=6
            if(y_int>480-1-6):
                y_int=480-1-6
            if(y_int<6):
                y_int=6
            
            for t1 in range(-3,3):
                for t2 in range(-3,3):
                    outframe[y_int+t1,x_int+t2,0]=255
                    outframe[y_int+t1,x_int+t2,1]=255

            #output_image[int(point_proj[1]),int(point_proj[0]),2]=255
            
           # outframe[y_int,x_int,0]=0
           # outframe[y_int,x_int,1]=0
            #print("point")
            pass
        
        
        angle_read=get_device_angle(angle_read)
        device_angle_raw=[angle_read[0]-116.1,257.7-angle_read[1],angle_read[2]-290]
        device_rad=[0,0,0]

        device_rad=[math.radians(device_angle_raw[0]),math.radians(device_angle_raw[1]),math.radians(device_angle_raw[2])]
        print(device_angle_raw)
        
        end_pos=forward_kinematics(device_rad,link_len)
        end_pos4=np.zeros((4,1), dtype = np.float)
        for i in range(0,3):
            end_pos4[i]=end_pos[i]
        end_pos4[3]=1.0
        
        pos_rot=mat_rot*end_pos4
        pos_trans=mat_trans*pos_rot
        pos_proj=mat_projection*pos_trans
        
        pos_proj[0]+=0.5*screen_w
        pos_proj[1]+=0.5*screen_h
        
        y_int=int(pos_proj[1])
        x_int=int(pos_proj[0])
        if(x_int>640-1-12):
            x_int=640-1-12
        if(x_int<12):
            x_int=12
        if(y_int>480-1-12):
            y_int=480-1-12
        if(y_int<12):
            y_int=12
        
        for t1 in range(-6,6):
            for t2 in range(-6,6):
                outframe[y_int+t1,x_int+t2,0]=255
                outframe[y_int+t1,x_int+t2,2]=255
        
        cv2.rectangle(outframe,(x_int,y_int),(x_int+3,y_int+3),(255,0,0),2)
        print(y_int,x_int,"pos")

        print("cycle test")
        hdmi_out.writeframe(outframe)
        print("frame output finished")
        
    pass
    hdmi_out.stop()
    del hdmi_out

 
if __name__ == '__main__':
    main()
    print ('now __name__ is %s' %__name__)

