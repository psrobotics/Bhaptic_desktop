import numpy as np
import math
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import numpy.matlib
import cv2
from pynq.overlays.base import BaseOverlay
from pynq.lib.video import *
base = BaseOverlay("base.bit")

def init():
    print("read init done")

def rawdepth_meter(depth):
    if(depth<256):
        new_depth=depth*8.0313
        print("depth")
        return (1.0 / new_depth * -0.0030711016 + 3.3309495161)
    return 0

def depth_point(x,y,depth):
    fx_d = 1.0 / 5.9421434211923247e+02
    fy_d = 1.0 / 5.9104053696870778e+02
    cx_d = 3.3930780975300314e+02
    cy_d = 2.4273913761751615e+02
    point = np.zeros((3,1), dtype = np.float) #important for address reflush
    point[0]=(x - cx_d) * depth * fx_d
    print("p0:",point[0])
    point[1]=(y - cy_d) * depth * fy_d
    print("p1:",point[1])
    point[2]=rawdepth_meter(depth)
    print("p2:",point[2])
    return point
    
def get_pcl(inframe):
    point_cloud=[]
    for i in range(0,640-1):
        for p in range(0,480-1):
            print(i,p,inframe[i,p,0])
            point_cloud.append(depth_point(i,p,inframe[i,p,0]))
            pass
        pass
    return point_cloud

def get_pcl_hdmi(inframe):
    point_cloud=[]
    for i in range (0,90):
        for n in range (0,60):
            point = np.zeros((3,1), dtype = np.float) #important for address reflush
            point[0]=inframe[n,i,0]/200-0.5
            point[1]=inframe[n,i,1]/200-0.5
            point[2]=inframe[n,i,2]/200-0.5
            point_cloud.append(point)
            pass
        pass
    return point_cloud
            

def get_file(file_name,zoom_k):
    point_cloud=[]
    with open(file_name,'r') as file_read:
        print("readin file ", (file_name))
        count=0
        while True:
            line=file_read.readline()
            if not line:
                break
            x_tmp,y_tmp,z_tmp,f_1,f_2,f_3=[float(i) for i in line.split()]
            point = np.zeros((3,1), dtype = np.float) #important for address reflush
            point[0]=x_tmp*zoom_k
            point[1]=y_tmp*zoom_k
            point[2]=z_tmp*zoom_k
            point_cloud.append(point)
            count=count+1
    point_cloud=np.array(point_cloud)
    print(point_cloud)
    print("read finished with ",(len(point_cloud))," points")
    file_read.close()
    return point_cloud

def gen_rotatex(rad_x):
    mat_rotx=np.matlib.identity(4,np.float)
    mat_rotx[1,1]=math.cos(rad_x)
    mat_rotx[1,2]=math.sin(rad_x)
    mat_rotx[2,1]=-1*math.sin(rad_x)
    mat_rotx[2,2]=math.cos(rad_x)
    print(mat_rotx)
    return mat_rotx

def gen_rotatey(rad_y):
    mat_roty=np.matlib.identity(4,np.float)
    mat_roty[0,0]=math.cos(rad_y)
    mat_roty[0,2]=math.sin(rad_y)
    mat_roty[2,0]=-1*math.sin(rad_y)
    mat_roty[2,2]=math.cos(rad_y)
    print(mat_roty)
    return mat_roty


def gen_rotatez(rad_z):
    mat_rotz=np.matlib.identity(4,np.float)
    mat_rotz[0,0]=math.cos(rad_z)
    mat_rotz[0,1]=math.sin(rad_z)
    mat_rotz[1,0]=-1*math.sin(rad_z)
    mat_rotz[1,1]=math.cos(rad_z)
    print(mat_rotz)
    return mat_rotz

def gen_rotmat(rad_x,rad_y,rad_z):
    mat_rotx=gen_rotatex(rad_x)
    mat_roty=gen_rotatey(rad_y)
    mat_rotz=gen_rotatez(rad_z)
    mat_rot=np.matlib.identity(4,np.float)
    mat_rot=mat_rotx*mat_roty*mat_rotz
    return mat_rot

def gen_transmat(x,y,z):
    mat_trans=np.matlib.identity(4,np.float)
    mat_trans[3,0]=x
    mat_trans[3,1]=y
    mat_trans[3,2]=z
    print(mat_trans)
    return mat_trans

def gen_projection( fov_deg, aspect_retio, near_f, far_f):
    fov_rad = 1.0 / math.tan(fov_deg * 0.5 / 180.0 * math.pi)
    result=np.zeros((4,4))
    result[0,0] = aspect_retio * fov_rad
    result[1,1] = fov_rad
    result[2,2] = far_f / (far_f - near_f)
    result[3,2] = (-far_f * near_f) / (far_f - near_f)
    result[2,3] = 1.0
    result[3,3] = 0.0
    print(result)
    return result

def draw_point(p_x,p_y):
    plt.scatter(p_x,p_y)
    plt.xlabel('x_axis')
    plt.ylabel('y_axis')
    plt.title('test_pcl_draw')
    plt.show()

def draw_point_3d(p_x,p_y,p_z):
    fig=plt.figure();
    ax = fig.add_subplot(111, projection='3d')
    ax.scatter(p_x,p_y,p_z,c='k',marker='.',s=0.1)
    plt.show()

def draw_point_cv(image_show):
    pass

def point_simplify(point_input,div_rate):
    ori_size=len(point_input)
    point_output=[]
    count=0
    for point_single in point_input:
        if count==0:
            point_output.append(point_single)
        count=count+1
        if count==div_rate:
            count=0
    return point_output

 
def main():
    #point_cloud=get_file("point-cloud-sample/horse.xyz",8.0)
    #print("point cloud file read done")
    #point_cloud=point_simplify(point_cloud,10)
    hdmi_in = base.video.hdmi_in
    hdmi_out = base.video.hdmi_out
    Mode = VideoMode(640,480,24)
    hdmi_in.configure(PIXEL_RGB)
    print(hdmi_in.mode)
    hdmi_out.configure(Mode, PIXEL_RGB)
    hdmi_in.start()
    hdmi_out.start()
    outf=hdmi_out.newframe()
    print("hdmi init done")
    frame = hdmi_in.readframe()
    print("read done")

    near_f=0.1
    far_f=1000.0
    fov_angle=90.0

    screen_w=640
    screen_h=480

    aspect_ratio=screen_h/screen_w

    display_angle=0
    display_offset={0,0,3.0}

    mat_projection=gen_projection(fov_angle, aspect_ratio, near_f, far_f)
    

    #cv2.namedWindow("test")
    for i in range(1000):
        inframe=hdmi_in.readframe()
        point_cloud=get_pcl_hdmi(inframe)
        #point_cloud=point_simplify(point_cloud,10)
        
        display_angle+=0.05
        mat_rot=gen_rotmat(display_angle,display_angle,display_angle)
        mat_trans=gen_transmat(0,0,3.0)

        outframe = hdmi_out.newframe()
        outframe[0:480,0:640,:]=255
        
        for point_single in point_cloud:
            point_single4=np.zeros((4,1), dtype = np.float)
            point_single4[3]=1.0

            point_single4[0]=point_single[0]
            point_single4[1]=point_single[1]
            point_single4[2]=point_single[2]

            point_rot=mat_rot*point_single4
            point_trans=mat_trans*point_rot
            point_proj=mat_projection*point_trans


            point_proj[0]+=1.0
            point_proj[1]+=1.0
            point_proj[0]*=0.5*screen_w
            point_proj[1]*=0.5*screen_h

            #output_image[int(point_proj[1]),int(point_proj[0]),2]=255
            outframe[int(point_proj[1]),int(point_proj[0]),0]=0
            outframe[int(point_proj[1]),int(point_proj[0]),1]=0

        print("cycle test")
        hdmi_out.writeframe(outframe)
        print("frame output finished")
        
    pass
    hdmi_out.stop()
    del hdmi_out
        
 
if __name__ == '__main__':
    main()
    print ('now __name__ is %s' %__name__)
